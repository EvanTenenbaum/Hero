/**
 * Agent Orchestrator Service
 * 
 * Manages the creation, execution, and orchestration of multi-agent workflows
 * in the HERO IDE system.
 */

import { EventEmitter } from 'events';
import { randomUUID } from 'crypto';

/**
 * Defines the types of agents available in the HERO IDE ecosystem.
 */
export type AgentType = 'pm' | 'developer' | 'qa' | 'devops' | 'research';

/**
 * Represents the status of a workflow step.
 */
export type StepStatus = 'pending' | 'running' | 'completed' | 'failed' | 'skipped';

/**
 * Represents the result of a task execution.
 */
export interface TaskResult {
    success: boolean;
    output: Record<string, unknown>;
    error?: string;
    logs: string[];
}

/**
 * Represents the input structure for creating a workflow step.
 */
export interface WorkflowStepInput {
    /** Unique identifier for the step within the workflow. */
    id: string;
    /** The type of agent responsible for executing this step. */
    agentType: AgentType;
    /** The specific task description for the agent. */
    task: string;
    /** Input data required for the task. */
    inputs: Record<string, unknown>;
    /** Array of step IDs that this step depends on. */
    dependsOn: string[];
}

/**
 * Represents a single step in a multi-agent workflow.
 */
export interface WorkflowStep extends WorkflowStepInput {
    /** Current status of the step. */
    status: StepStatus;
    /** Output data generated by the step. */
    outputs?: Record<string, unknown>;
    /** Error message if the step failed. */
    error?: string;
    /** Start timestamp of the step execution. */
    startedAt?: Date;
    /** Completion timestamp of the step execution. */
    completedAt?: Date;
}

/**
 * Represents a complete multi-agent workflow.
 */
export interface AgentWorkflow {
    /** Unique identifier for the workflow. */
    id: string;
    /** Human-readable name of the workflow. */
    name: string;
    /** The sequence of steps in the workflow. */
    steps: WorkflowStep[];
    /** Overall status of the workflow. */
    status: 'pending' | 'running' | 'completed' | 'failed' | 'paused' | 'cancelled';
    /** Timestamp when the workflow was created. */
    createdAt: Date;
    /** Timestamp when the workflow was completed (if applicable). */
    completedAt?: Date;
}

/**
 * Represents the final result of a workflow execution.
 */
export interface WorkflowResult {
    /** ID of the executed workflow. */
    workflowId: string;
    /** True if the workflow completed successfully. */
    success: boolean;
    /** Final state of all steps. */
    steps: WorkflowStep[];
    /** Overall error message if the workflow failed. */
    error?: string;
    /** Total duration of the execution in milliseconds. */
    duration: number;
}

/**
 * Represents a request for one agent to delegate a task to another.
 */
export interface DelegationRequest {
    /** The agent initiating the delegation. */
    fromAgent: AgentType;
    /** The agent receiving the delegated task. */
    toAgent: AgentType;
    /** The specific task being delegated. */
    task: string;
    /** Contextual information for the delegated task. */
    context: Record<string, unknown>;
    /** Priority level of the task. */
    priority: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * Represents the status summary of a running or paused workflow.
 */
export interface WorkflowStatus {
    id: string;
    name: string;
    status: AgentWorkflow['status'];
    progress: {
        total: number;
        completed: number;
        running: number;
        pending: number;
    };
}

/**
 * Configuration for the orchestrator.
 */
interface OrchestratorConfig {
    /** Maximum number of concurrent steps to execute. */
    maxConcurrency: number;
    /** Retry attempts for failed steps. */
    maxRetries: number;
}

/**
 * Manages the creation, execution, and orchestration of multi-agent workflows.
 */
export class AgentOrchestrator extends EventEmitter {
    private workflows: Map<string, AgentWorkflow> = new Map();
    private config: OrchestratorConfig;

    /**
     * Initializes the AgentOrchestrator.
     * @param config Configuration options for the orchestrator.
     */
    constructor(config: Partial<OrchestratorConfig> = {}) {
        super();
        this.config = {
            maxConcurrency: 5,
            maxRetries: 3,
            ...config,
        };
        console.log('[AgentOrchestrator] Initialized');
    }

    /**
     * Creates a new multi-agent workflow definition.
     * @param name The name of the workflow.
     * @param steps The array of steps defining the workflow.
     * @returns The newly created AgentWorkflow object.
     * @throws {Error} If the workflow steps contain circular dependencies.
     */
    public createWorkflow(name: string, steps: WorkflowStepInput[]): AgentWorkflow {
        const workflowId = randomUUID();
        const initialSteps: WorkflowStep[] = steps.map(step => ({
            ...step,
            status: 'pending',
        }));

        // Validate dependencies and check for cycles
        this.validateDependencies(initialSteps);

        const newWorkflow: AgentWorkflow = {
            id: workflowId,
            name,
            steps: initialSteps,
            status: 'pending',
            createdAt: new Date(),
        };

        this.workflows.set(workflowId, newWorkflow);
        this.emit('workflowCreated', newWorkflow);
        return newWorkflow;
    }

    /**
     * Executes a defined workflow, managing step dependencies and parallel execution.
     * @param workflowId The ID of the workflow to execute.
     * @returns A promise that resolves with the final WorkflowResult.
     * @throws {Error} If the workflow is not found or is already running/completed.
     */
    public async executeWorkflow(workflowId: string): Promise<WorkflowResult> {
        const workflow = this.getWorkflow(workflowId);
        if (!workflow) {
            throw new Error(`Workflow with ID ${workflowId} not found.`);
        }
        if (workflow.status === 'running' || workflow.status === 'completed' || workflow.status === 'failed') {
            throw new Error(`Workflow ${workflowId} is already ${workflow.status}.`);
        }

        const startTime = Date.now();
        workflow.status = 'running';
        this.emit('workflowStarted', workflowId);

        try {
            // 1. Topological Sort to determine execution order
            const sortedSteps = this.topologicalSort(workflow.steps);
            const stepMap = new Map(workflow.steps.map(s => [s.id, s]));

            // 2. Execution Loop
            let completedCount = 0;
            const runningPromises: Map<string, Promise<void>> = new Map();

            while (completedCount < sortedSteps.length) {
                if (workflow.status !== 'running') {
                    throw new Error(`Workflow execution stopped due to status change: ${workflow.status}`);
                }

                // Identify steps ready to run (pending and dependencies met)
                const readySteps = sortedSteps.filter(stepId => {
                    const step = stepMap.get(stepId)!;
                    return step.status === 'pending' && this.areDependenciesMet(step, stepMap);
                });

                // Execute ready steps, respecting concurrency limit
                for (const stepId of readySteps) {
                    const step = stepMap.get(stepId)!;

                    if (runningPromises.size >= this.config.maxConcurrency) {
                        break; // Concurrency limit reached
                    }

                    step.status = 'running';
                    step.startedAt = new Date();
                    this.emit('stepStarted', workflowId, step);

                    const executionPromise = this.executeStepWithRetry(workflowId, step)
                        .then(() => {
                            step.status = 'completed';
                            step.completedAt = new Date();
                            completedCount++;
                            runningPromises.delete(stepId);
                            this.emit('stepCompleted', workflowId, step);
                        })
                        .catch(error => {
                            step.status = 'failed';
                            step.error = error.message || 'Unknown execution error';
                            completedCount++;
                            runningPromises.delete(stepId);
                            this.emit('stepFailed', workflowId, step, error);
                            throw error;
                        });

                    runningPromises.set(stepId, executionPromise);
                }

                // Wait for at least one running step to complete
                if (runningPromises.size > 0) {
                    try {
                        await Promise.race(Array.from(runningPromises.values()));
                    } catch {
                        // A step failed, stop execution
                        workflow.status = 'failed';
                        break;
                    }
                } else if (completedCount < sortedSteps.length) {
                    // Deadlock detection
                    const blockedSteps = sortedSteps.filter(stepId => stepMap.get(stepId)!.status === 'pending');
                    if (blockedSteps.length > 0) {
                        throw new Error(`Workflow deadlock detected. Steps blocked: ${blockedSteps.join(', ')}`);
                    }
                }
            }

            // Finalize
            if (workflow.status === 'running') {
                workflow.status = 'completed';
            }
            workflow.completedAt = new Date();
            this.emit('workflowCompleted', workflowId, workflow.status === 'completed');

            return {
                workflowId,
                success: workflow.status === 'completed',
                steps: workflow.steps,
                error: workflow.status === 'failed' ? 'One or more steps failed' : undefined,
                duration: Date.now() - startTime,
            };

        } catch (error) {
            workflow.status = 'failed';
            workflow.completedAt = new Date();
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.emit('workflowCompleted', workflowId, false, errorMessage);

            return {
                workflowId,
                success: false,
                steps: workflow.steps,
                error: errorMessage,
                duration: Date.now() - startTime,
            };
        }
    }

    /**
     * Handles the delegation of a task from one agent to another.
     * @param request The delegation request details.
     * @returns A promise resolving to the result of the delegated task.
     */
    public async delegate(request: DelegationRequest): Promise<TaskResult> {
        console.log(`[AgentOrchestrator] Delegation: ${request.fromAgent} -> ${request.toAgent} (Task: ${request.task})`);
        this.emit('delegationRequested', request);

        try {
            // Simulate agent processing
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 100));

            const result: TaskResult = {
                success: true,
                output: {
                    message: `Task "${request.task}" completed by ${request.toAgent}.`,
                    context: request.context,
                },
                logs: [`Delegation received from ${request.fromAgent}`],
            };

            this.emit('delegationCompleted', request, result);
            return result;
        } catch (error) {
            const result: TaskResult = {
                success: false,
                error: error instanceof Error ? error.message : 'Delegation failed',
                output: {},
                logs: [],
            };
            this.emit('delegationFailed', request, result);
            throw new Error(`Delegation failed: ${result.error}`);
        }
    }

    /**
     * Retrieves the status summary of all active workflows.
     * @returns An array of WorkflowStatus objects.
     */
    public getActiveWorkflows(): WorkflowStatus[] {
        const activeStatuses: AgentWorkflow['status'][] = ['pending', 'running', 'paused'];
        return Array.from(this.workflows.values())
            .filter(w => activeStatuses.includes(w.status))
            .map(w => ({
                id: w.id,
                name: w.name,
                status: w.status,
                progress: {
                    total: w.steps.length,
                    completed: w.steps.filter(s => s.status === 'completed' || s.status === 'failed').length,
                    running: w.steps.filter(s => s.status === 'running').length,
                    pending: w.steps.filter(s => s.status === 'pending').length,
                },
            }));
    }

    /**
     * Retrieves a specific workflow by its ID.
     * @param workflowId The ID of the workflow.
     * @returns The AgentWorkflow object or undefined if not found.
     */
    public getWorkflow(workflowId: string): AgentWorkflow | undefined {
        return this.workflows.get(workflowId);
    }

    /**
     * Pauses a running workflow.
     * @param workflowId The ID of the workflow to pause.
     */
    public pauseWorkflow(workflowId: string): void {
        const workflow = this.getWorkflow(workflowId);
        if (!workflow) {
            throw new Error(`Workflow ${workflowId} not found.`);
        }
        if (workflow.status !== 'running') {
            throw new Error(`Workflow ${workflowId} is not running (status: ${workflow.status}).`);
        }
        workflow.status = 'paused';
        this.emit('workflowPaused', workflowId);
    }

    /**
     * Resumes a paused workflow.
     * @param workflowId The ID of the workflow to resume.
     */
    public resumeWorkflow(workflowId: string): void {
        const workflow = this.getWorkflow(workflowId);
        if (!workflow) {
            throw new Error(`Workflow ${workflowId} not found.`);
        }
        if (workflow.status !== 'paused') {
            throw new Error(`Workflow ${workflowId} is not paused (status: ${workflow.status}).`);
        }
        workflow.status = 'running';
        this.emit('workflowResumed', workflowId);
    }

    /**
     * Cancels a running or pending workflow.
     * @param workflowId The ID of the workflow to cancel.
     */
    public cancelWorkflow(workflowId: string): void {
        const workflow = this.getWorkflow(workflowId);
        if (!workflow) {
            throw new Error(`Workflow ${workflowId} not found.`);
        }
        if (workflow.status === 'completed' || workflow.status === 'failed') {
            throw new Error(`Workflow ${workflowId} is already finalized (status: ${workflow.status}).`);
        }
        workflow.status = 'cancelled';
        workflow.completedAt = new Date();
        this.emit('workflowCancelled', workflowId);
    }

    /**
     * Executes a single step with retry logic.
     */
    private async executeStepWithRetry(workflowId: string, step: WorkflowStep): Promise<void> {
        let attempts = 0;
        let lastError: Error | null = null;

        while (attempts < this.config.maxRetries) {
            attempts++;
            try {
                const result = await this.simulateAgentExecution(step);

                if (result.success) {
                    step.outputs = result.output;
                    return;
                } else {
                    throw new Error(result.error || 'Agent execution failed');
                }
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                console.warn(`[AgentOrchestrator] Step ${step.id} failed on attempt ${attempts}. Error: ${lastError.message}`);
                this.emit('stepRetrying', workflowId, step, attempts, lastError);

                if (attempts < this.config.maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
                }
            }
        }

        throw new Error(`Step ${step.id} failed after ${this.config.maxRetries} attempts. Last error: ${lastError?.message}`);
    }

    /**
     * Simulates agent execution (placeholder for actual agent invocation).
     */
    private async simulateAgentExecution(step: WorkflowStep): Promise<TaskResult> {
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));

        // 90% success rate for simulation
        const isSuccess = Math.random() > 0.1;

        if (isSuccess) {
            return {
                success: true,
                output: {
                    agent: step.agentType,
                    result: `Successfully executed task: ${step.task}`,
                    processedInputs: step.inputs,
                },
                logs: [`${step.agentType} completed task ${step.id}`],
            };
        } else {
            return {
                success: false,
                error: `Simulated failure for ${step.agentType} on task: ${step.task}`,
                output: {},
                logs: [`${step.agentType} encountered an error.`],
            };
        }
    }

    /**
     * Checks if all dependencies for a step are met.
     */
    private areDependenciesMet(step: WorkflowStep, stepMap: Map<string, WorkflowStep>): boolean {
        return step.dependsOn.every(depId => {
            const depStep = stepMap.get(depId);
            return depStep?.status === 'completed';
        });
    }

    /**
     * Performs topological sort on workflow steps.
     */
    private topologicalSort(steps: WorkflowStep[]): string[] {
        const graph = new Map<string, string[]>();
        const inDegree = new Map<string, number>();
        const stepIds = steps.map(s => s.id);

        stepIds.forEach(id => {
            graph.set(id, []);
            inDegree.set(id, 0);
        });

        for (const step of steps) {
            for (const depId of step.dependsOn) {
                if (!stepIds.includes(depId)) {
                    throw new Error(`Step ${step.id} depends on non-existent step ${depId}.`);
                }
                graph.get(depId)!.push(step.id);
                inDegree.set(step.id, inDegree.get(step.id)! + 1);
            }
        }

        const queue: string[] = stepIds.filter(id => inDegree.get(id) === 0);
        const sortedOrder: string[] = [];

        while (queue.length > 0) {
            const u = queue.shift()!;
            sortedOrder.push(u);

            for (const v of graph.get(u)!) {
                inDegree.set(v, inDegree.get(v)! - 1);
                if (inDegree.get(v) === 0) {
                    queue.push(v);
                }
            }
        }

        if (sortedOrder.length !== steps.length) {
            const cycleNodes = stepIds.filter(id => inDegree.get(id)! > 0);
            throw new Error(`Circular dependency detected. Nodes involved: ${cycleNodes.join(', ')}`);
        }

        return sortedOrder;
    }

    /**
     * Validates workflow dependencies.
     */
    private validateDependencies(steps: WorkflowStep[]): void {
        this.topologicalSort(steps);
    }
}
